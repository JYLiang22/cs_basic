- [解密TCP三次握手和四次挥手](#解密tcp三次握手和四次挥手)
- [TCP 三次握手异常情况实战分析](#tcp-三次握手异常情况实战分析)
  - [TCP 第一次握手 SYN 丢包](#tcp-第一次握手-syn-丢包)
  - [TCP 第二次握手 SYN、ACK 丢包](#tcp-第二次握手-synack-丢包)
  - [TCP 第三次握手 ACK 丢包](#tcp-第三次握手-ack-丢包)
- [TCP 快速建立连接](#tcp-快速建立连接)
- [TCP 重复确认和快速重传](#tcp-重复确认和快速重传)
- [TCP 流量控制](#tcp-流量控制)
  - [零窗口通知与窗口探测](#零窗口通知与窗口探测)
  - [发送窗口的分析](#发送窗口的分析)
- [TCP 延迟确认与 Nagle 算法](#tcp-延迟确认与-nagle-算法)


这一节很好地解释了上一节的内容，同时也让我更加明白了网络需要这些东西的意义：
1. 提高传输数据准确率
2. 提高网络利用率、降低时延


# 解密TCP三次握手和四次挥手


# TCP 三次握手异常情况实战分析
解决一下这几个问题：
1. TCP 第一次握手的 SYN 丢包了，会发生了什么？
2. TCP 第二次握手的 SYN、ACK 丢包了，会发生什么？
3. TCP 第三次握手的 ACK 包丢了，会发生什么？
4. 那会重传几次？
5. 超时重传的时间 RTO 会如何变化？
6. 在 Linux 下如何设置重传次数？
7. ....


## TCP 第一次握手 SYN 丢包
1. 超时重传SYN数据包
2. 重传次数是由 tcp_syn_retries 决定的，是可以通过指令设置的，如果达到重传次数上限后，客户端将不会再次发送SYN包
3. RTO是指数变化的，$2^x$


## TCP 第二次握手 SYN、ACK 丢包
1. 客户端会超时重发 SYN 包，服务端也会超时重传 SYN、ACK 包
2. TCP 第二次握手 SYN、ACK 包的最大重传次数是通过 tcp_synack_retries 内核参数限制的


## TCP 第三次握手 ACK 丢包
1. 服务端会超时重传 SYN、ACK 包，当超过了最大重传次数 tcp_synack_retries，服务端的 TCP 连接就会主动断开
2. 客户端有两种状态
   - 向服务端发送数据报文时，如果迟迟没有收到数据包的确认报文，也会触发超时重传，最大超时重传次数是由 tcp_retries2 指定，默认值是 15 次
   - 如果客户端不发送数据，什么时候才会断开处于 ESTABLISHED 状态的连接？**保活机制**


# TCP 快速建立连接
其实也是使用了缓存的功能，实现了快速建立连接。<br>
主要经历了三个过程：<br>
常规HTTP请求(2.5个RTT) -> 第三次握手带数据(2个RTT) -> TCP Fast Open(第二次请求只要一个RTT)


# TCP 重复确认和快速重传


# TCP 流量控制


## 零窗口通知与窗口探测


## 发送窗口的分析


# TCP 延迟确认与 Nagle 算法
出现原因：网络中有小报文传输时，网络效率是很低的，因为传输数据的开销 > 有效数据量<br>
方法：
1. Nagle算法
   - 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；
   - 条件二：收到之前发送数据的 ack 回包
2. 延迟确认  **解决ACK网络效率低**
   - 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
   - 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
   - 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK
3. 延迟确认 和 Nagle 算法混合使用时，会产生新的问题