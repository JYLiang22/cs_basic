- [介绍](#介绍)
- [结构](#结构)
- [代码实现](#代码实现)
- [优缺点](#优缺点)


# 介绍

在不改变一个对象本身功能的基础上给对象增加额外的新行为，动态地给一个对象增加一些额外的职责。就拓展功能而言，它提供了一种比使用子类更加灵活的替代方案。<br>


# 结构

如下图所示：<br><br>![Alt text](%E7%BB%93%E6%9E%84.png)<br>

1. 抽象构件(Component)：具体构件类和装饰类的共同基类
2. 具体构件(ConcreteComponent)：定义了构件具体的方法，装饰类可以给它增加更多的功能
3. 抽象装饰类(Decorator)：用于给具体构建增加职责，但具体职责在子类中实现
4. 具体装饰类(ConcreteDecorator)：向构件增加新的功能


# 代码实现

[卡码网](https://kamacoder.com/problempage.php?pid=1086)<br>


# 优缺点

优点：<br>

1. 对于拓展一个类的新功能，装饰模式比继承要灵活
2. 动态拓展一个对象的功能
3. 可以对一个对象多次装饰
4. 具体构建类和具体装饰类可以独立变化和拓展，符合开闭原则

缺点：<br>

1. 该模式会产生很多小的对象，对象的区别在于各种装饰的连接方式不同，而不是职责不同，大量小对象的产生会占用较多的系统资源
2. 装饰模式比继承更灵活，但是更容易出错和更难排错

适用场景：<br>

1. 在不影响其他对象的情况下，给单个对象动态拓展职责
2. 不适宜采用继承的方式拓展的时候，可以考虑使用装饰模式