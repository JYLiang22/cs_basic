- [引言](#引言)
- [计算机硬件的操作数](#计算机硬件的操作数)
  - [存储器操作数](#存储器操作数)
  - [常数或立即数操作数](#常数或立即数操作数)
- [计算机中的指令表示](#计算机中的指令表示)
- [逻辑操作](#逻辑操作)
- [决策指令](#决策指令)
  - [循环](#循环)
  - [边界检查的简便方法](#边界检查的简便方法)
  - [case/switch语句](#caseswitch语句)
- [计算机硬件对过程的支持](#计算机硬件对过程的支持)
  - [使用更多的寄存器](#使用更多的寄存器)


# 引言

本书所选的指令集是ARMv8，用LEGv8(Lessen Extrinsic Garrulity)表示教学的指令集，这个集合是基于ARMv8指令集的。<br>

LEGv8操作数如下图所示：<br>![Alt text](image/LEGv8%E6%93%8D%E4%BD%9C%E6%95%B0.png)<br>

LEGv8汇编语言：<br>![Alt text](image/LEGv8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.png)<br>


# 计算机硬件的操作数

LEGv8 体系结构中每个寄存器的大小为 64，它将 64 位称为双字(doubleword), 32 位称为字(word)。<br>


## 存储器操作数

为什么出现？<br>
在编程语言中，有仅含一个数据元素的简单变量，也有如数组和结构体那样复杂的数据结构，这些复杂数据结构中的数据元素可能远多于计算机中寄存器的个数。处理器只能将少量数据保存在寄存器中，但存储器可以存放数十亿的数据元素 因此，数据结构（如数组和结构体）存放在存储器中。<br>

因此出现了数据传输指令：在存储器和寄存器之间移动数据的命令。<br>
取数指令：存储器 -> 寄存器<br>
LDUR 中的 U 表示不可扩展的 (unscaled) 立即数，和可扩展的 (scaled) 立即数。<br>

***例题：编译一个操作数在存储器中的赋值语句***<br>
设A是一个含有 100 个双字的数组，编译器将寄存器 X20、X21 依次分配给变量g、h。又设数组A的起始地址(或称基址 (base address)) 存放在寄存器 X22 中。试编译下面的 C 赋值语句：<br>

```
g  = h + A[8];
```

因为有一个操作数在存储器中，所以需要使用数据传输指令。答案如下：<br>

```
LDUR X9, [X22, #8]   // Temporary reg X9 gets A[8] 
ADD X20, X21, X9   // g  = h + A[8]
```

***例题：用load/store进行编译***<br>
假设变量 h 存放在寄存器 X21 中，数组 A 的基址放在 X22 中。 那么下面 C 赋值语句的 LEGv8 汇编代码是怎样的？<br>
```
A[12] = h + A[8];
```

解答：<br>
```
LDUR X9, [X22, #64]   // Temporary reg X9 gets A[8]
ADD X9, X9, X21   // Temporary reg X9 gets h + A[8] 
STUR X9, [X22, #96]   //  Stores h + A[8] back into A[12] 
```

将不常使用的变量（或稍后才使用的变量）存放到存储器中的过程叫作寄存器溢出 (spilling register)。<br>
寄存器比存储器访问时间短、吞吐量高：
1. 根据硬件设计原则 (越少越快)，存储器肯定比寄存器慢，因为寄存器数量更少。事实的确如此，访问寄存器中的数据要快于访问存储器中的数据。
2. 此外，寄存器中的数据更容易利用。一条 LEGv8 算术运算指令能读两个寄存器，对它们进行运算，并将结果写回。一条 LEGv8 数据传输指令只能读或写一个操作数，且不能对它们进行运算。


## 常数或立即数操作数

为什么出现？<br>
程序中经常会在某个操作中使用到常数，如果仅使用目前已介绍过的指令，使用常数时则必须先将其从存储器中取出(常数可能
是在程序被加载进主存时放人存储器的)。例如，要使寄存器 X22 加 4, 可以使用以下代码：<br>

```
LDUR X9, [X20, AddConstant4]   // X9 = constant 4
ADD X22, X22, X9   // X22 = X22 + X9(X9 == 4)
```

所以出现了立即数操作指令，可以避免使用load指令：<br>
```
ADDI X22, X22, #4   // X22 = X22 + 4
```


# 计算机中的指令表示

三种指令格式：<br>

R型指令，用于寄存器：<br>![Alt text](image/R%E5%9E%8B%E6%8C%87%E4%BB%A4.png)<br>![Alt text](image/R%E5%9E%8B%E6%8C%87%E4%BB%A4%E5%90%84%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89.png)<br>

D型指令，用于数据传输，load和store：<br>![Alt text](image/D%E5%9E%8B%E6%8C%87%E4%BB%A4.png)<br>

I型指令，用于立即数操作：<br>![Alt text](image/I%E5%9E%8B%E6%8C%87%E4%BB%A4.png)<br>

指令设计要求规整，单一格式，那为什么要设计三种不同格式的指令呢？<br>

1. load register (取寄存器)指令必须指定两个寄存和一个常数。在上述格式中 如果地址使用其中的一个5位字段，那么load register指令最大的常数就被限制在$2^5 - 1$ (即31)。这个常数通常用来从数组或数据结构中选择元素，所以常常比31大得多。因此，5位字段太小，难以发挥作用。所以出现了D指令.
2. 尽管D型指令中的9位字段可以用来存放常量，但是ARMv8的设计者认为应该提供更大的字段存放立即数，甚至将操作码字段减少一位以构成12位的立即数。

三种指令格式由第一个字段区分，常见的LEGv8指令中每个字段的值：<br>![Alt text](image/%E5%B8%B8%E8%A7%81%E7%9A%84LEGv8%E6%8C%87%E4%BB%A4%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC.png)<br>


# 逻辑操作

常见逻辑操作表示：<br>![Alt text](image/%E5%B8%B8%E8%A7%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E8%A1%A8%E7%A4%BA.png)<br>

前面介绍的R型指令中的shamt字段用于移位指令中：<br>![Alt text](image/shamt%E5%AD%97%E6%AE%B5%E7%94%A8%E4%BA%8E%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4%E4%B8%AD.png)<br>

为了**保持三操作数的形式**，ARMv8的设计者引入异或指令(EOR)来取代NOT。在异或中，若两个操作数相同，则结果为0，否则为1。所以取反操作NOT相当于和全1数做EOR操作。<br>


# 决策指令

LEGv8中有两条决策指令，统称为条件分支：<br>

```
// CBZ表示比较0分支(compare and branch if zero)
CBZ register, L1   // 如果register的值为0，则转到标签为L1的语句执行
```

```
// CBNZ表示比较不为0分支(compare and branch if not zero)
CBNZ register, L1   // 如果register的值不为0，则转到标签为L1的语句执行
```

***例题：将if-then-else语句编译成条件分支语句***<br>
下面这段代码，f、g、h、i、j都是变量，依次对应五个寄存器X19到X23。写出这条C语言编写的if语句编译后形成的LEGv8代码。<br>

```C
if(i == j)
  f = g + h;
else
  f = g - h;
```

LEGv8代码：<br>

```LEGv8
SUB X9, X22, X23   // X9 = i - j
CBNZ X9, Else   // go to Else if i ≠ j
ADD X19, X20, X21   // f = g + h
B Exit   // go to Exit
Else: SUB X19, X20, X21   // f = g - h
Exit:
```

解释：<br>
1. 前面介绍的条件分支指令只能判断一个寄存器的值是否为0，因此第一步要将i和j相减，检查结果是否为0
2. 通过测试分支的相反条件来跳过比较不相等要执行的代码，这样的代码效率会更高，故这里使用 CBNZ 指令
3. 在if语句的结尾部分，需要引入另一种分支指令，通常叫做无条件分支指令(unconditional branch)，当遇到这种指令，处理器必须跳转。LEGv8将无条件分支指令命名为branch，简写成B
4. 要将标签Else加入else的赋值语句前，同时指令后面加入标签EXit，表示这段代码编译结束


## 循环

***例题：编译C语言中的while循环***<br>
下面是用C语言编写的一个传统循环程序：<br>

```C
while(save[i] == k)
  i += 1;
```

假设i和k存放在寄存器X22和X24中，数组save的基址存放在寄存器X25中，写出这段C程序对应的LEGv8对应的汇编代码。<br>

LEGv8代码：<br>

```LEGv8
Loop: LSL X10, X22, #3   // Temp reg X10 = i * 8
ADD X10, X10, X25   // X[10] = address of save[i]
LDUR X9, [X10, #0]   // Temp reg X9 = save[i]
SUB X11, X9, X24   // X11 = save[i] - k
CBNZ X11, Exit   // go to Exit if save[i] ≠ k(X[11] ≠ 0)
ADDI X22, X22, #1   // i = i + 1
B Loop   // go to Loop
Exit:
```

解释：<br>

1. 第一步需要将save[i]读入临时寄存器中比较save[i]和k的大小，读入之前首先需要计算save[i]的地址。
2. 由于LEGv8使用字节编址，所以需要将i*8再加到save[i]数组基址形成访存地址，这个可以使用左移指令实现。同时要在左移指令前加一个标签Loop，以便在循环末尾能够跳回该指令。

除了是否相等，还有其它关系用于比较。他们的条件分支指令和条件码如下：<br>![Alt text](image/%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4.png)<br>![Alt text](image/%E6%9D%A1%E4%BB%B6%E7%A0%81.png)<br>

四条检测单一条件码的分支指令：<br>![Alt text](image/%E6%A3%80%E6%B5%8B%E5%8D%95%E4%B8%80%E6%9D%A1%E4%BB%B6%E7%A0%81%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4.png)<br>

使用条件码的缺点：如果许多指令频繁设置条件码，就可能造成依赖性问题，使得指令很难流水执行。<br>
所以LEGv8只允许少量指令可以设置条件码：ADD，ADDI，AND，ANDI，SUB，SUBI。<br>
在LEGv8中，如果想要设置条件码， 只需要在相应指令尾部加上S，如ADDS，ADDIS，ANDS，ANDIS，SUBS，SUBIS。可以解释为：ADDS，add and set flags，加并设置标志位。<br>


## 边界检查的简便方法

<font color=red>**这里看不懂**</font><br>

将有符号数作为无符号数来处理，是一种检验 0 ≤ x < y 的开销较低的方法。因为计算机采用二进制补码，符号位参与运算，因此计算机本身是不区分有符号数和无符号数。因为最高有效位在有符号数中是符号位，而在无符号数中是具有最大权重的位。所以以无符号数比较 x < y, 可以在检查 x 是否小于 y 的同时，检查 x 是否为负数。<br>

***例题：***<br>
用以下方法检查索引是否越界：如果X20 ≥ X11 或 X20 是负数，则跳转到IndexOutOfBounds处。<br>
只需要使用一条无符号数大于或等于指令即可以完成两种检查：<br>

```
SUBS XZR, X20, X11   // Test if X20 >= length or X20 < 0
B.HS IndexOutOfBounds   // if bad, goto Error
```

为什么可以判断X20是负数？XZR寄存器始终为0，只能影响标志位，不可以影响结果。<br>


## case/switch语句

介绍了这个语句的实现原理：将switch语句转化为一组if-then-else语句。<br>

但是有一种更有效的方法：将多个指令序列的地址编码为一张表，即 **分支地址表** 或 **分支表**。程序只需要索引该表就可以跳转到正确的指令序列。<br>


# 计算机硬件对过程的支持

过程：根据传入的参数完成一定任务的子程序。<br>

LEGv8软件在为过程调用分配寄存器时遵循以下约定：<br>

1. X0 ~ X7：作为参数寄存器(8个)，用于传递参数或返回结果
2. LR(X30)：作为返回地址寄存器(存放过程调用的返回地址)，用于返回原始调用点
3. 分支和链接指令(branch-and-link instruction)BL


## 使用更多的寄存器

由于任务完成后必须消除过程产生的踪迹，因此调用者原先使用的寄存器都必须恢复到过程调用前的状态，这种情况可以看成是需要将寄存器溢出(换出)到存储器的一个例子，而换出寄存器最理想的数据结构是栈。<br>
栈指针：指示栈中最近分配的地址，表明寄存器被换出的位置，或寄存器旧值的存放位置。在每次寄存器进行保存和恢复时，栈指针(stack pointer，SP)以一个双字为单位进行调整。<br>
栈从高地址向低地址增长，这意味着压栈时，SP值减小；弹栈时，SP增大。<br>

***例题：***<br>
编译一个不调用其他过程的C过程：
```C
long long int leaf_example(long long int g, long long int h, long long int i, long long int j){
  long long int f;
  f = (g + h) - (i + j);
  return f;
}
```