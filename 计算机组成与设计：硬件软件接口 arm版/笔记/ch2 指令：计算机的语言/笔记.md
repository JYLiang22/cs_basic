- [引言](#引言)
- [计算机硬件的操作数](#计算机硬件的操作数)
  - [存储器操作数](#存储器操作数)
  - [常数或立即数操作数](#常数或立即数操作数)


# 引言

本书所选的指令集是ARMv8，用LEGv8(Lessen Extrinsic Garrulity)表示教学的指令集，这个集合是基于ARMv8指令集的。<br>

LEGv8操作数如下图所示：<br>![Alt text](image/LEGv8%E6%93%8D%E4%BD%9C%E6%95%B0.png)<br>

LEGv8汇编语言：<br>![Alt text](image/LEGv8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80.png)<br>


# 计算机硬件的操作数

LEGv8 体系结构中每个寄存器的大小为 64，它将 64 位称为双字(doubleword), 32 位称为字(word)。<br>


## 存储器操作数

为什么出现？<br>
在编程语言中，有仅含一个数据元素的简单变量，也有如数组和结构体那样复杂的数据结构，这些复杂数据结构中的数据元素可能远多于计算机中寄存器的个数。处理器只能将少量数据保存在寄存器中，但存储器可以存放数十亿的数据元素 因此，数据结构（如数组和结构体）存放在存储器中。<br>

因此出现了数据传输指令：在存储器和寄存器之间移动数据的命令。<br>
取数指令：存储器 -> 寄存器<br>
LDUR 中的 U 表示不可扩展的 (unscaled) 立即数，和可扩展的 (scaled) 立即数。<br>

***例题：编译一个操作数在存储器中的赋值语句***<br>
设A是一个含有 100 个双字的数组，编译器将寄存器 X20、X21 依次分配给变量g、h。又设数组A的起始地址(或称基址 (base address)) 存放在寄存器 X22 中。试编译下面的 C 赋值语句：<br>

```
g  = h + A[8];
```

因为有一个操作数在存储器中，所以需要使用数据传输指令。答案如下：<br>

```
LDUR X9, [X22, #8]   // Temporary reg X9 gets A[8] 
ADD X20, X21, X9   // g  = h + A[8]
```

***例题：用load/store进行编译***<br>
假设变量 h 存放在寄存器 X21 中，数组 A 的基址放在 X22 中。 那么下面 C 赋值语句的 LEGv8 汇编代码是怎样的？<br>
```
A[12] = h + A[8];
```

解答：<br>
```
LDUR X9, [X22, #64]   // Temporary reg X9 gets A[8]
ADD X9, X9, X21   // Temporary reg X9 gets h + A[8] 
STUR X9, [X22, #96]   //  Stores h + A[8] back into A[12] 
```

将不常使用的变量（或稍后才使用的变量）存放到存储器中的过程叫作寄存器溢出 (spilling register)。<br>
寄存器比存储器访问时间短、吞吐量高：
1. 根据硬件设计原则 (越少越快)，存储器肯定比寄存器慢，因为寄存器数量更少。事实的确如此，访问寄存器中的数据要快于访问存储器中的数据。
2. 此外，寄存器中的数据更容易利用。一条 LEGv8 算术运算指令能读两个寄存器，对它们进行运算，并将结果写回。一条 LEGv8 数据传输指令只能读或写一个操作数，且不能对它们进行运算。


## 常数或立即数操作数

为什么出现？<br>
程序中经常会在某个操作中使用到常数，如果仅使用目前已介绍过的指令，使用常数时则必须先将其从存储器中取出(常数可能
是在程序被加载进主存时放人存储器的)。例如，要使寄存器 X22 加 4, 可以使用以下代码：<br>

```
LDUR X9, [X20, AddConstant4]   // X9 = constant 4
ADD X22, X22, X9   // X22 = X22 + X9(X9 == 4)
```

所以出现了立即数操作指令，可以避免使用load指令：<br>
```
ADDI X22, X22, #4   // X22 = X22 + 4
```

