# 内存管理


## 为什么会出现allocator类

如果面试官问了解new、delete之类的问题，就可以先回答new/delete、malloc/free的知识，之后可以参考[allocator类](<../../C++ Primer/第十二章 动态内存.md>)，展开说：

1. new/delete的缺点，所以要提出allocator
2. allocator的用法


## 虚函数内存模型

**参考：[一文读懂C++虚函数的内存模型](https://blog.csdn.net/weixin_43798887/article/details/118196343)**<br>

1. **虚函数和多态性**：
    首先，解释虚函数是C++中实现多态性的一种机制。多态性允许我们通过基类指针或引用调用派生类的函数，使得同一个函数调用可以有不同的行为。

2. **虚函数表（V-Table）**：
    接着，提到虚函数是通过虚函数表（V-Table）来实现的。每个拥有虚函数的类都有一个V-Table，它是一个函数指针数组，每个指针指向类的虚函数实现。

3. **V-Table的布局**：
    描述V-Table通常包含在对象的内存布局的最前面，这样可以通过对象的地址直接访问V-Table，从而快速确定调用哪个函数。

4. **继承和V-Table**：
    在继承的情况下，派生类的V-Table会覆盖基类的V-Table中的相应函数指针，以指向派生类中的覆盖函数。

5. **单继承和多重继承**：
    对于单继承，派生类的V-Table会包含基类V-Table的所有函数指针，以及派生类特有的虚函数指针。
    对于多重继承，每个基类都有自己的V-Table，但派生类只有一个V-Table，它包含了所有基类和派生类虚函数的指针。每个基类的V-Table指针会存储在派生类对象的内存中，以确保通过基类指针调用虚函数时可以找到正确的V-Table。

6. **V-Table的创建和使用**：
    描述编译器在编译时会为每个有虚函数的类生成V-Table，并且在运行时，对象的构造函数会初始化V-Table指针。

7. **实际应用**：
    最后，给出一个简单的代码示例，展示如何通过基类指针调用派生类的虚函数，并解释背后的内存模型。


## 虚继承内存模型

**参考：[一文读懂C++虚继承的内存模型](https://blog.csdn.net/weixin_43798887/article/details/118369498)**<br>

1. **虚继承的概念**：
    首先，解释虚继承是C++中用来解决多继承导致的菱形继承问题的机制。在多继承中，如果两个基类都继承自同一个类，那么派生类会从这两个基类中继承两份该基类的成员。虚继承允许派生类只保留一份共享基类的成员。

2. **虚继承的语法**：
    指出在类继承时使用 `virtual` 关键字来指定虚继承，例如 `class Derived : virtual public Base`。

3. **内存模型的特点**：
    描述虚继承的内存模型中，虚基类成员在派生类对象中只有一份拷贝，并且位于派生类对象的内存布局的最末尾部分。
    提到为了能够正确地访问虚基类成员，编译器会使用两个特殊的指针：`vbase_offset` 和 `offset_to_top`。`vbase_offset` 存储了虚基类子对象相对于派生类对象地址的偏移，而 `offset_to_top` 存储了最顶级基类（非虚基类）子对象相对于派生类对象地址的偏移。

4. **虚表（V-Table）**：
    我会解释在虚继承中，虚表不仅包含虚函数的地址，还包含了 `vbase_offset` 和 `offset_to_top` 的信息，以确保在多态情况下正确地访问虚基类成员。

5. **调试验证**：
    说明可以使用GDB等调试工具来查看类的内存布局，验证虚继承的内存模型。


# C++11新特性


## lambda表达式

**了解lambda表达式吗？**<br>
可以参考[lambda表达式](<../../C++ Primer/第十章 泛型算法.md>)，从以下几方面介绍：

1. lambda表达式出现的原因
2. lambda表达式的形式和使用方式
3. lambda表达式捕获列表的捕获方式和区别

接下去引申说lambda表达式的缺点，介绍下bind，可参考[参数绑定](<../../C++ Primer/第十章 泛型算法.md>)：

1. lambda表达式的缺点，介绍bind出现原因
2. bind的形式和含义
3. bind1st和bind2nd的区别

接下去还可以拓展下函数调用运算符，说这两个都是函数调用运算符，还有以下的函数调用运算符：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数运算符的类：

1. 匿名函数，因为重载了()使得用起来像函数，必须是成员函数
2. 标准库定义的函数对象，例如加减乘除、大于小于、与或非

接下去可以引出function，主要介绍它出现的原因。<br>


# STL

1. [allocator类](<../C++ Primer/第十二章 动态内存.md>)
2. emplace_back 和 push_back
   1. [Why emplace_back is faster than push_back?](https://stackoverflow.com/questions/23717151/why-emplace-back-is-faster-than-push-back)<br>
   2. [C++中push_back和emplace_back的区别](https://developer.aliyun.com/article/771502)<br>


# C++内置库函数

1. std::move和std::forward

    [C++11中std::move和std::forward到底干了啥](https://blog.csdn.net/albertsh/article/details/118886009?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-118886009-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>
    [C++11的右值引用、移动语义（std::move）和完美转发（std::forward）详解](https://blog.csdn.net/weixin_43798887/article/details/117091176?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-117091176-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>
    [C++的std::move与std::forward原理大白话总结](https://blog.csdn.net/newchenxf/article/details/117995131?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-117995131-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>

2. std::function和std::bind

    [C++11的std::function和std::bind用法详解](https://blog.csdn.net/qq_38410730/article/details/103637778?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565173716800227492494%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171565173716800227492494&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-103637778-null-null.142^v100^control&utm_term=std%3A%3Afunction&spm=1018.2226.3001.4187)<br>


# C++内存管理

[经典内存池实现](https://blog.csdn.net/K346K346/article/details/49538975?spm=1001.2014.3001.5506)<br>
[C/C++内存管理详解](https://blog.csdn.net/Fire_Cloud_1/article/details/131521776?spm=1001.2014.3001.5506)<br>


# 关键字

[深入理解C++中五种强制类型转换的使用场景](https://blog.csdn.net/weixin_43798887/article/details/118424172)<br>
[assert断言函数简介](https://blog.csdn.net/weixin_61561736/article/details/124886522?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565547816800213026389%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565547816800213026389&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-124886522-null-null.142^v100^control&utm_term=assert&spm=1018.2226.3001.4187)<br>
[C++ explicit关键字详解](https://blog.csdn.net/guoyunfei123/article/details/89003369?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565195216800215019777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565195216800215019777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-89003369-null-null.142^v100^control&utm_term=explicit&spm=1018.2226.3001.4187)<br>


# 智能指针

[C++11的智能指针shared_ptr、weak_ptr源码解析](https://blog.csdn.net/weixin_43798887/article/details/116464334)<br>
[C++的智能指针auto_ptr、unique_ptr源码解析](https://blog.csdn.net/weixin_43798887/article/details/118104317)<br>
[C++11新特性之十：enable_shared_from_this](https://blog.csdn.net/caoshangpa/article/details/79392878?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171818999016800186554642%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171818999016800186554642&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-79392878-null-null.142^v100^control&utm_term=enable_shared_from_this&spm=1018.2226.3001.4187)<br>


# C++多线程

1. [【C++入门到精通】互斥锁 (Mutex) C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135041309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565531916800213071534%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565531916800213071534&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-135041309-null-null.142^v100^control&utm_term=mutex&spm=1018.2226.3001.4187)
2. [【C++入门到精通】condition_variable（条件变量）C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135074541?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565534916800227491852%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565534916800227491852&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-135074541-null-null.142^v100^control&utm_term=condition_variable&spm=1018.2226.3001.4187)
3. [【C++入门到精通】Lock_guard与Unique_lock C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135041872?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565552716800182786124%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565552716800182786124&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-135041872-null-null.142^v100^control&utm_term=lock_guard&spm=1018.2226.3001.4187)
4. [C++11 多线程（std::thread）详解](https://blog.csdn.net/sjc_0910/article/details/118861539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565575316800185845874%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565575316800185845874&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-118861539-null-null.142^v100^control&utm_term=std%3A%3Athread&spm=1018.2226.3001.4187)
5. [C++11多线程 unique_lock详解](https://blog.csdn.net/u012507022/article/details/85909567?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565479316800186586537%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565479316800186586537&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-85909567-null-null.142^v100^control&utm_term=unique_lock&spm=1018.2226.3001.4187)
6. [ThreadLocal](https://blog.csdn.net/u010445301/article/details/111322569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171833026916800213067166%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171833026916800213067166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-111322569-null-null.142^v100^control&utm_term=thread_local&spm=1018.2226.3001.4187)
7. [【C++】atomic原子操作](https://blog.csdn.net/qq_60755751/article/details/134808243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171859136716800186556698%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171859136716800186556698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-19-134808243-null-null.142^v100^control&utm_term=C%2B%2Batomic&spm=1018.2226.3001.4187)
8. [C++多线程：Atomic原子类与CAS锁详解](https://blog.csdn.net/weixin_43808717/article/details/137250676?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171859136716800186556698%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171859136716800186556698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-22-137250676-null-null.142^v100^control&utm_term=C%2B%2Batomic&spm=1018.2226.3001.4187)

