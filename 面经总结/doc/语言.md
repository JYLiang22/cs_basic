# 声明

全文基本参考自[阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-04-01-STL.html)，个人只是觉得他那里有比较多的问题重复冗余，所以整理了下。这里只是目录的整理，具体内容由于时间关系没有列出。


# C++基础


## 指针

### 指针和引用的区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_3%E3%80%81%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 常量指针和指针常量

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_17%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%88%AB)<br>

### 函数指针

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_82%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88)<br>

### 区分以下指针类型

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_7%E3%80%81%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B)<br>

### 野指针和悬空指针

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_31%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88)<br>

### 数组中a和&a有什么区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_18%E3%80%81a%E5%92%8C-a%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)<br>

### 数组名和指针区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_26%E3%80%81%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88-%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88-%E5%8C%BA%E5%88%AB)<br>

### 指针加减计算要注意什么

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-04-basic.html#_74%E3%80%81%E6%8C%87%E9%92%88%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88)<br>


## 关键字/运算符

### const

### static

### define和typedef的区别

### define和inline的区别

### define和const的区别

### new/malloc和delete/free系列

### const和constexpr

### violatile

### mutable

### explicit

### extern "C"的用法

### 前置++和后置++

### struct和class

### strlen和sizeof

### final和override

### 构造函数中的default和delete

### string和char*

### strcpy和memcpy

### strcpy和strncpy


## 变量

### 变量声明和变量定义

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_15%E3%80%81%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%88%AB)<br>

### 全局变量和static变量

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_94%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8Cstatic%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 静态成员和普通成员

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_95%E3%80%81-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)<br>

### 形参和实参区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_45%E3%80%81%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 值传递、指针传递、引用传递

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_46%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E3%80%81%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E3%80%81%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E6%95%88%E7%8E%87)<br>

### 静态变量什么时候初始化

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_47%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96)<br>


## 强制类型转换

参考[深入理解C++中五种强制类型转换的使用场景](https://blog.csdn.net/weixin_43798887/article/details/118424172)<br>

`static_cast` 可用于以下转换：
1. 用于基本内置数据类型之间的转换。
2. 用于指针之间的转换，但明确规定不同类型的指针不可以直接转换，只能使用 `void*` 作为中间参数；直接不允许不同类型的引用进行转换的，因为没有void类型引用可以作为中间介质。
3. 不能转换 `const` 或 `volitale` 属性，也就是说不能把 `const int *` 转换为 `int *`。
4. 用于类实例的之间转换：上行转换是安全且合法的；下行转换需要在子类中加一个使用父类进行构造的构造函数才可以转换。
5. 用于没有多态的类实例指针或引用之间的转换：上行转换是完全安全的；进行下行转换（基类指针->派生类指针、基类引用->派生类引用）由于缺乏安全检查，所以是有问题的，要尽量避免这种用法。
6. 用于具有多态的类实例指针或引用之间的转换：上行转换都是正常的；进行下行转换（基类指针->派生类指针、基类引用->派生类引用）由于缺乏安全检查，所以是有问题的，要尽量避免这种用法。

`const_cast` 的作用是去除掉const或volitale属性，前面介绍static_cast的时候我们知道static_cast是不具备这种功能的。但要注意：const_cast不是用于去除变量的常量性，而是**去除指向常量对象的指针或引用的常量性**，其去除常量性的对象**必须为指针或引用**，并且const_cast不支持不同类型指针或引用之间的转换，比如说float* 转换成int* 是不允许的，直白一点说就是**type_id和expression要基本类型保持一致**，相差的话只能差const或volatile属性。<br>

`reinterpret_cast` 是C风格强制类型转换，重点如下，具体看文章。
1. 使用格式如下：`reinterpret_cast<type_id>(expression);` 
2. type-id和expression中必须有一个是指针或引用类型（可以两个都是指针或引用，指针引用在一定场景下可以混用，但是建议不要这样做，编译器也会给出相应的警告）。
3. 第一种用途是改变指针或引用的类型；第二种用途是将指针或引用转换为一个整型，这个整型必须与当前系统指针占的字节数一致；第三种用途是将一个整型转换为指针或引用类型。

`dynamic_cast` 是C++风格强制类型转换，前三个都是编译的时候完成，他是在运行的时候处理的。可用于以下转换，具体看博客：
1. 不能用于内置基本数据类型的强制转换，并且dynamic_cast只能对指针或引用进行强制转换。
2. 如果转换成功的话返回的是指向类的指针或引用，转换失败的话则会返回nullptr。
3. 进行上行转换时，与static_cast的效果是完全一样的。
4. 进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。并且这种情况下dynamic_cast会要求进行转换的类必须具有多态性（即具有虚表，直白来说就是有虚函数或虚继承的类），否则编译不通过。


# 内存管理


## 基础

### C++内存分区

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_2%E3%80%81%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8Ec-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA)<br>

### 堆和栈的区别，哪个更快

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_5%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_6%E3%80%81%E4%BD%A0%E8%A7%89%E5%BE%97%E5%A0%86%E5%BF%AB%E4%B8%80%E7%82%B9%E8%BF%98%E6%98%AF%E6%A0%88%E5%BF%AB%E4%B8%80%E7%82%B9)<br>

### 结构体内存对齐

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-basic.html#_2%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_83%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0)<br>

### 对象复用和零拷贝

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-04-basic.html#_62%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3)<br>

### 为什么会出现allocator类

如果面试官问了解new、delete之类的问题，就可以先回答new/delete、malloc/free的知识，之后可以参考 **[allocator类](<../../C++ Primer/第十二章 动态内存.md>)** ，展开说：

1. new/delete的缺点，所以要提出allocator
2. allocator的用法

### 什么是内存泄漏，如何避免

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_8%E3%80%81-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%90%8E%E6%9E%9C-%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95)<br>

### 如何实现内存池

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0)<br>

### coredump

如何处理coredump？(回答以Ubuntu 22.04为例)<br>

首先确定当前程序可以出现内核转储文件，使用 `ulimit -c` 检查，如果没开启，使用`ulimit -c 指定容量大小` 开启。开启后重新执行程序，会发现报错信息后面出现 `core dumped` 字眼，代表可以生成内核转储文件。<br>
上述方法仅对当前连接有效，如果想要永久修改，应该修改配置文件 `vim /etc/security/limits.conf` ，找到 `#* soft core 0` 这一行，把 0 改为 unlimited，然后执行 `source /etc/security/limits.conf` 或者重启使得刚刚的配置生效。<br>
之后可以使用 `cat /proc/sys/kernel/core_pattern`，查看当前 coredump 文件生成目录及命名规则。接着使用 `g++ -g -o file.out file.cpp` 生成调试文件，之后就可以使用 `gdb -c 生成的内核转储文件 生成的调试文件` 进入 gdb进行调试。<br>


## 类相关

### 深拷贝和浅拷贝

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_35%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_51%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E5%8F%AF%E4%BB%A5%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%90%97)<br>

### 类的对象存储空间

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_1%E3%80%81%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4)<br>

### 数据成员和成员函数内存分布情况

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_5%E3%80%81c-%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5)<br>

### 类对象的大小受什么影响

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_15%E3%80%81%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D)<br>

### 空类的大小是多少

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_12%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93%E7%A9%BA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91%E5%90%97)<br>

### 以下几个类的大小

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_13%E3%80%81%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B-%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91)<br>


# C++泛型编程

## 模板全特化和偏特化

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_5%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96)<br>

模板分为类模板与函数模板，特化分为特例化（全特化）和部分特例化（偏特化）。对模板特例化是因为对特定类型，可以利用某些特定知识来提高效率，而不是使用通用模板。<br>

对函数模板：

1. 模板和特例化版本应该声明在同⼀头文件，所有同名模板的声明应放在前面，接着是特例化版本。
2. ⼀个模板被称为全特化的条件：1.必须有⼀个主模板类 2.模板类型被全部明确化。

函数模板只有全特化，偏特化可以通过函数的重载实现。<br>

```cpp
template<typename T1, typename T2>
void fun(T1 a, T2 b){
	cout << "函数模板" << endl;
}

template<>
void fun<int, char>(int a, char b){
	cout << "全特化" << endl;
}
```

类模板：对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类 > 偏特化类 > 主版本模板类。<br>

```cpp
template<typename T1, typename T2>
class Test{
public:
	Test(T1 i, T2 j): a(i), b(j){
		cout << "模板类" << endl;
	}

private:
	T1 a;
	T2 b;
};

template<>
class Test<int , char>{
public:
	Test(int i, char j): a(i), b(j){
		cout << "全特化" << endl;
	}

private:
	int a;
	char b;
};

template<typename T2>
class Test<char, T2>{
public:
	Test(char i, T2 j): a(i), b(j){
		cout << "偏特化" << endl;
	}

private:
	char a;
	T2 b;
};
```


## 比较大小的模板

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-06-basic.html#_119%E3%80%81%E6%A8%A1%E6%9D%BF%E4%BC%9A%E5%86%99%E5%90%97-%E5%86%99%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0)<br>


## 为什么模板类一般都是放在一个h文件中

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_88%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AAh%E6%96%87%E4%BB%B6%E4%B8%AD)<br>


# C++面向对象


## 基本特性

### 封装继承多态

### 组合与继承

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_81%E3%80%81%E7%9F%A5%E9%81%93c-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%E5%90%97-%E5%AE%83%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%90%97)<br>

### 类成员访问权限和继承权限问题

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_89%E3%80%81c-%E4%B8%AD%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98)<br>

### 静态成员和普通成员

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-05-basic.html#_95%E3%80%81-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)<br>

### 友元函数和友元类

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-07-basic.html#_127%E3%80%81%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5)<br>

### tihs指针都知道什么

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_6%E3%80%81%E5%85%B3%E4%BA%8Ethis%E6%8C%87%E9%92%88%E4%BD%A0%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88-%E5%85%A8%E8%AF%B4%E5%87%BA%E6%9D%A5)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_7%E3%80%81%E5%87%A0%E4%B8%AAthis%E6%8C%87%E9%92%88%E7%9A%84%E6%98%93%E6%B7%B7%E9%97%AE%E9%A2%98)<br>

### 类的成员函数和析构函数中调用delete this，分别会发生什么

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_9%E3%80%81%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-02-01-memory.html#_11%E3%80%81-%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88)<br>

### 各类函数可以声明成内联函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_6%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0)<br>

### 虚继承问题

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_20%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF)<br>

### 如何看待多继承

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_24%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%BC%80%E5%8F%91%E8%80%85%E6%80%8E%E4%B9%88%E7%9C%8B%E5%BE%85%E5%A4%9A%E7%BB%A7%E6%89%BF)<br>


## 构造、析构函数

### 有哪几种构造函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_34%E3%80%81c-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)<br>

### 构造函数执行顺序

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_58%E3%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B)<br>

### 构造函数、拷贝构造函数和赋值操作符区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_18%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 什么情况下自动生成默认构造函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_21%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)<br>

### 什么情况下会调用拷贝构造函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_40%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)<br>

### 什么情况下会合成拷贝构造函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_32%E3%80%81%E9%82%A3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%90%88%E6%88%90%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%91%A2)<br>

### 为什么拷贝构造函数必须传引用

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_27%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC)<br>
感觉说得不是很清楚，可以看看这个[博客](https://blog.csdn.net/Hackbuteer1/article/details/6545882)<br>

### 构造函数的执行顺序

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_33%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_11%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E7%9A%84%E5%86%85%E9%83%A8%E9%83%BD%E5%B9%B2%E4%BA%86%E5%95%A5)<br>

### 移动构造函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-04-basic.html#_68%E3%80%81%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_30%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)<br>

### 空类会添加什么函数

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-06-basic.html#_103%E3%80%81%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB-%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0)<br>

### 析构函数作用

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_9%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E7%94%A8)<br>

### 虚析构函数作用

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_12%E3%80%81%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8-%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0)<br>

### 类什么时候会析构

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_15%E3%80%81%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%9E%90%E6%9E%84)<br>


## 初始化

### 初始化和赋值区别

[➡️](https://juejin.cn/post/7069353642179969032)<br>

### 拷贝初始化和直接初始化

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_28%E3%80%81%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96)<br>

### 哪些情况必须用到成员列表初始化

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-03-basic.html#_59%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)<br>


## 多态

### 如何实现

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_1%E3%80%81c-%E7%9A%84%E5%A4%9A%E6%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0)<br>

### 重载、重写和隐藏区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-02-basic.html#_33%E3%80%81c-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96-%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 静态类型和动态类型、静态绑定和动态绑定

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-04-basic.html#_71%E3%80%81%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D)<br>

### 动态编译和静态编译

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-07-basic.html#_129%E3%80%81%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91)<br>


## 虚函数系列

### 什么函数可以是虚函数？为什么？

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_8%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E5%87%BD%E6%95%B0)<br>
[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2)<br>

### 虚函数表存放在什么区？虚表指针vptr初始化时间？

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-01-other.html#_4%E3%80%81%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA-%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4)<br>

### 虚函数和纯虚函数区别

[➡️](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-05-02-other.html#_36%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB)<br>

### 虚函数内存模型

**参考：[一文读懂C++虚函数的内存模型](https://blog.csdn.net/weixin_43798887/article/details/118196343)**<br>

1. **虚函数和多态性**：
    首先，解释虚函数是C++中实现多态性的一种机制。多态性允许我们通过基类指针或引用调用派生类的函数，使得同一个函数调用可以有不同的行为。

2. **虚函数表（V-Table）**：
    接着，提到虚函数是通过虚函数表（V-Table）来实现的。每个拥有虚函数的类都有一个V-Table，它是一个函数指针数组，每个指针指向类的虚函数实现。

3. **V-Table的布局**：
    描述V-Table通常包含在对象的内存布局的最前面，这样可以通过对象的地址直接访问V-Table，从而快速确定调用哪个函数。

4. **继承和V-Table**：
    在继承的情况下，派生类的V-Table会覆盖基类的V-Table中的相应函数指针，以指向派生类中的覆盖函数。

5. **单继承和多重继承**：
    对于单继承，派生类的V-Table会包含基类V-Table的所有函数指针，以及派生类特有的虚函数指针。
    对于多重继承，每个基类都有自己的V-Table，但派生类只有一个V-Table，它包含了所有基类和派生类虚函数的指针。每个基类的V-Table指针会存储在派生类对象的内存中，以确保通过基类指针调用虚函数时可以找到正确的V-Table。

6. **V-Table的创建和使用**：
    描述编译器在编译时会为每个有虚函数的类生成V-Table，并且在运行时，对象的构造函数会初始化V-Table指针。

7. **实际应用**：
    最后，给出一个简单的代码示例，展示如何通过基类指针调用派生类的虚函数，并解释背后的内存模型。

### 虚继承内存模型

**参考：[一文读懂C++虚继承的内存模型](https://blog.csdn.net/weixin_43798887/article/details/118369498)**<br>

1. **虚继承的概念**：
    首先，解释虚继承是C++中用来解决多继承导致的菱形继承问题的机制。在多继承中，如果两个基类都继承自同一个类，那么派生类会从这两个基类中继承两份该基类的成员。虚继承允许派生类只保留一份共享基类的成员。

2. **虚继承的语法**：
    指出在类继承时使用 `virtual` 关键字来指定虚继承，例如 `class Derived : virtual public Base`。

3. **内存模型的特点**：
    描述虚继承的内存模型中，虚基类成员在派生类对象中只有一份拷贝，并且位于派生类对象的内存布局的最末尾部分。
    提到为了能够正确地访问虚基类成员，编译器会使用两个特殊的指针：`vbase_offset` 和 `offset_to_top`。`vbase_offset` 存储了虚基类子对象相对于派生类对象地址的偏移，而 `offset_to_top` 存储了最顶级基类（非虚基类）子对象相对于派生类对象地址的偏移。

4. **虚表（V-Table）**：
    我会解释在虚继承中，虚表不仅包含虚函数的地址，还包含了 `vbase_offset` 和 `offset_to_top` 的信息，以确保在多态情况下正确地访问虚基类成员。

5. **调试验证**：
    说明可以使用GDB等调试工具来查看类的内存布局，验证虚继承的内存模型。


# C++11新特性


## 都有什么新特性


## NULL和nullptr区别


## lambda表达式

**了解lambda表达式吗？**<br>
可以参考 **[lambda表达式](<../../C++ Primer/第十章 泛型算法.md>)** ，从以下几方面介绍：

1. lambda表达式出现的原因
2. lambda表达式的形式和使用方式
3. lambda表达式捕获列表的捕获方式和区别

接下去引申说lambda表达式的缺点，介绍下bind，可参考[参数绑定](<../../C++ Primer/第十章 泛型算法.md>)：

1. lambda表达式的缺点，介绍bind出现原因
2. bind的形式和含义
3. bind1st和bind2nd的区别

接下去还可以拓展下函数调用运算符，说这两个都是函数调用运算符，还有以下的函数调用运算符：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数运算符的类：

1. 匿名函数，因为重载了()使得用起来像函数，必须是成员函数
2. 标准库定义的函数对象，例如加减乘除、大于小于、与或非

接下去可以引出function，主要介绍它出现的原因。<br>


## 左值引用和右值引用

左值（Located-value）：是指那些具有持久存储的变量，它们在程序执行过程中一直存在，并且可以被取地址。<br>
特点：
1. 可以出现在赋值表达式的左边或右边。
2. 可以有多个引用。
3. 可以被 & 运算符取地址。

右值（Read-value）：是指那些临时的、不具有持久存储的表达式，它们通常在表达式求值后就不再存在。
特点：
1. 只能出现在赋值表达式的右边（C++11 之前）。
2. 不能有多个引用。
3. 不能被 & 运算符取地址。

左值引用和右值引用其实本质都是为了减少无效的拷贝，区别在于：左值引用是对左值的引用，它必须绑定到一个已经存在的持久对象上，定义时使用 & 符号；右值引用是 C++11 引入的一种引用类型，它使用双写的 && 符号定义，可以绑定到右值上。


## 移动语义和完美转发

参考：[C++11中std::move和std::forward到底干了啥](https://blog.csdn.net/albertsh/article/details/118886009?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-118886009-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>

`std::move` 称为移动语义，里面首先通过 `std::remove_reference<_Tp>::type&&` 移除类型的引用，返回原始类型 `X`；之后再通过 `static_cast` 把参数强制转换为 `X&&`。这里的推导使用了折叠规则，如下：<br>
```
A& & 折叠成 A&
A& && 折叠成 A&
A&& & 折叠成 A&
A&& && 折叠成 A&&
```
可以看到，`std::move` 的内部只做了一个强制类型转换，告诉使用者这里可能进行了到右值的转化，相关的对象后续可能发生移动，“被掏空”了，如果你继续使用这个对象，行为是未定义的，后果自负。<br>
`std::forward` 称为完美转发，里面也是通过 `std::remove_reference<_Tp>::type` 和 `static_cast` 做了一个强制转换，当形参为左值时返回左值引用，形参为右值时返回右值引用。<br>
为什么要这么做，如果能记住，最好可以说下参考里面的例子。<br>


## 智能指针

### 原理

### 常用智能指针及实现

### 作用

### 循环引用问题

### 手写智能指针类需要实现什么函数


## 列表初始化


# STL


## emplace_back 和 push_back 的区别

参考[C++中push_back和emplace_back的区别](https://developer.aliyun.com/article/771502)<br>

相同点在于：它们都是用来在容器的末尾添加新元素的方法，如果在添加元素的时候，容器的容量如果满了，就会先扩容之后再添加元素。<br>
区别在于：

1. push_back 会使用传入的参数来构造新元素，之后再把新元素拷贝或移动到vector的内存中；
2. emplace_back 会尝试直接在vector的内存构造新元素，避免了拷贝或移动的操作。

这样的根本原因在于实现方式的区别，emplace_back在构造函数的时候使用的是std::forward，而std::forward本质上是一个类型转换函数static_cast。


## 指路

看[阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-04-01-STL.html)


# C++多线程

1. [【C++入门到精通】互斥锁 (Mutex) C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135041309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565531916800213071534%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565531916800213071534&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-135041309-null-null.142^v100^control&utm_term=mutex&spm=1018.2226.3001.4187)
2. [【C++入门到精通】condition_variable（条件变量）C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135074541?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565534916800227491852%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565534916800227491852&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-135074541-null-null.142^v100^control&utm_term=condition_variable&spm=1018.2226.3001.4187)
3. [【C++入门到精通】Lock_guard与Unique_lock C++11 [ C++入门 ]](https://blog.csdn.net/m0_75215937/article/details/135041872?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565552716800182786124%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565552716800182786124&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-135041872-null-null.142^v100^control&utm_term=lock_guard&spm=1018.2226.3001.4187)
4. [C++11 多线程（std::thread）详解](https://blog.csdn.net/sjc_0910/article/details/118861539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565575316800185845874%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565575316800185845874&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-118861539-null-null.142^v100^control&utm_term=std%3A%3Athread&spm=1018.2226.3001.4187)
5. [C++11多线程 unique_lock详解](https://blog.csdn.net/u012507022/article/details/85909567?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171565479316800186586537%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171565479316800186586537&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-85909567-null-null.142^v100^control&utm_term=unique_lock&spm=1018.2226.3001.4187)
6. [ThreadLocal](https://blog.csdn.net/u010445301/article/details/111322569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171833026916800213067166%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171833026916800213067166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-111322569-null-null.142^v100^control&utm_term=thread_local&spm=1018.2226.3001.4187)
7. [【C++】atomic原子操作](https://blog.csdn.net/qq_60755751/article/details/134808243?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171859136716800186556698%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171859136716800186556698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-19-134808243-null-null.142^v100^control&utm_term=C%2B%2Batomic&spm=1018.2226.3001.4187)
8. [C++多线程：Atomic原子类与CAS锁详解](https://blog.csdn.net/weixin_43808717/article/details/137250676?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171859136716800186556698%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171859136716800186556698&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-22-137250676-null-null.142^v100^control&utm_term=C%2B%2Batomic&spm=1018.2226.3001.4187)

