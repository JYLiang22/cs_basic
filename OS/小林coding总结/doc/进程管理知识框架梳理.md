![Alt text](../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.svg)<br>

# 进程、线程基础知识

**进程**：<br>

1. 通过读取文件的例子引入 **并发**，并介绍 **并发和并行** 的区别。<br>
2. 进程的状态：七状态图、如何转换、为什么要出现挂起状态等。<br>
3. 进程的控制结构：PCB、PCB包含什么信息、PCB如何组织。<br>
4. 进程的控制：创建、终止、阻塞、唤醒过程，可以结合项目里面的代码理解。<br>
5. 进程的上下文切换：为什么要出现、CPU上下文切换(进程/线程/中断上下文切换)、切换的是什么(用户/内核空间)、哪些场景发生(大多数都是调度、中断等场景)。<br>

**线程**：<br>

1. 为什么使用线程？举一个例子说明了单进程、多进程的缺点，进而提出线程。<br>
2. 什么是线程？共享和独占的分别是什么资源，有什么优缺点？<br>
3. 进程和线程的区别，**为什么线程切换开销比进程少**。<br>
4. 线程的上下文切换，具体看要切换的线程是不是属于同一个进程。<br>
5. 线程的实现：三种实现方式；用户线程和内核线程的三种对应方式，多对一、一对一、多对多；各有什么优缺点<br>

**调度**：<br>

1. 结合七状态图理解调度时机，结合调度原则理解常见调度算法。<br>
2. 调度算法的优缺点及发展：<br>
3. 先来先服务 -> 最短作业优先 -> 高响应比优先 -> 时间片轮转调度 -> 最高优先级 -> 多级反馈队列<br>


# 进程间通信

**管道**：<br>

1. 匿名管道，它的通信范围是存在父子关系的进程，通过 ```int pipe(int fd[2])``` 实现
2. 命名管道，它可以在不相关的进程间也能相互通信

消息保存在内核的缓冲区，先进先出，通信效率低，因此管道不适合进程间频繁地交换数据。<br>

**消息队列**：保存在内核中的信息链表，解决了管道不适合进程间频繁地交换数据的问题。但也有缺点，如下：<br>

1. 通信不及时(为什么？想不通)
2. 附件大小有限制，所以不适合大数据的传输
3. 通信过程中，存在用户态和内核态之间的数据拷贝开销

**共享内存**：拿出一块虚拟地址空间来，映射到相同的物理内存中，可以解决消息队列的读取和写入都会发生用户态与内核态之间的消息拷贝过程的问题。<br>

**信号量**：共享内存中，如果多个进程同时修改同一个共享内存，很有可能就冲突了。所以出现了信号量，来防止多进程竞争共享资源，而造成的数据错乱问题。理解PV操作，以及互斥信号量、同步信号量的区别。<br>

**信号**：对于异常情况下的工作模式，就需要用信号的方式来通知进程。它是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程。<br>

**Socket**：跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。


# 多线程冲突了怎么办

感觉这里和王道408的内容很像，先是介绍了互斥、同步的概念，接着讲了如何通过锁和信号量实现互斥、同步，最后分析了经典的生产者-消费者问题、哲学家就餐问题以及读者-写者问题。<br>


# 怎么避免死锁

这里的理论知识和书上一样，关键在于学习如何通过gdb分析、解决死锁。<br>


# 什么是悲观锁、乐观锁

最基础的锁：互斥锁和自旋锁，它们最大的区别在于加锁失败时的处理方式。<br>
通过线上文档的方式解释了乐观锁和悲观锁的区别。<br>


# 一个进程最多可以创建多少线程

受两个因素限制：进程虚拟内存空间上限、系统参数限制。<br>


# 线程崩溃了，进程也会崩溃吗

C/C++会，而JAVA不会；而且非法访问内存一定会导致进程崩溃。<br>
