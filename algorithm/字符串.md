- [技巧](#技巧)
- [库函数的使用](#库函数的使用)
- [KMP算法](#kmp算法)
- [常用字符串函数](#常用字符串函数)


# 技巧

1. 可以发现双指针在这类题目中出现频率很高
2. 当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章
3. 其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作，这么做有两个好处：<br>
   1. 不用申请新数组。
   2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。
4. 花式翻转：翻转再翻转，即使用整体反转+局部反转就可以实现反转单词顺序


# 库函数的使用

不单单要熟悉各个库函数的操作，还要熟悉库函数的底层原理，具体是如何实现这个操作的。<br>


# KMP算法

**在一个串中查找是否出现过另一个串**：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。<br>

这个目前不太理解，先放放！<br>


# 常用字符串函数

**定义和初始化string对象**：<br>

| 操作 | 含义 |
| -- | -- |
| string s1 | 默认初始化 |
| string s2(s1) | 直接初始化 |
| string s2 = s1 | 拷贝初始化 |
| string s3(n, 'c') | 把s3初始化为由连续n个字符c组成的串 |
| string s(cp, n) | s是cp指向的数组中前n个字符的拷贝 |
| string s(s2, pos2) | s是string s2从下标pos2开始的字符的拷贝 |
| string s(s2, pos2, len2) | s是string s2从下标pos2开始的len2个字符的拷贝 |
| s1.substr(pos, n) | 返回一个s1的子字符串，包含s1中从pos开始的n个字符的拷贝 |

**string对象上的操作**：<br>

| 操作 | 含义 |
| -- | -- |
| s.empty() | 判断s是否为空 |
| s.size() | 返回s中字符的个数 |
| getline(cin, lint) | 读取一整行 |

**处理string对象中的字符**，需要引入 **cctype** 头文件：<br>

| 操作 | 含义 |
| -- | -- |
| isalnum(c) | c为字母或数字为真 |
| isalpha(c) | c为字母为真 |
| isdigit(c) | c为数字为真 |
| islower(c) | c是小写字母为真 |
| isupper(c) | c是大写字母为真 |

**修改string的操作**：<br>

| 操作 | 含义 |
| -- | -- |
| s.insert(pos, args) | 在pos之前插入args指定的字符，pos可以是一个下标或迭代器。接受下标会返回一个指向s的引用，接受迭代器返回指向第一个插入字符的迭代器 |
| s.erase(pos, len) | 删除从pos开始的len个字符。如果len省略，则删除pos开始至s末尾的所有字符，返回一个指向s的引用 | 
| s.assign(args) | 将s中的字符替换为args指定的字符，返回一个指向s的引用 |
| s.append(args) | 将args追加到s，返回一个指向s的引用 |
| s.replace(range, args) | 删除s中范围range内的字符，替换为args指定的字符。range可以是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用 |

**string搜索操作**：<br>

| 操作 | 含义 |
| -- | -- |
| s.find(args) | 查找s中args第一次出现的位置 |
| s.rfind(args) | 查找s中args最后一次出现的位置 |
| s.find_first_of(args) | 在s中查找args中任何一个字符第一次出现的位置 |
| s.find_last_of(args) | 在s中查找args中任何一个字符最后一次出现的位置 |
| s.find_first_not_of(args) | 在s中查找第一个不在args中的字符 |
| s.find_last_not_of(args) | 在s中查找最后一个不在args中的字符 |