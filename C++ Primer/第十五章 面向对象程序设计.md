- [概述](#概述)
  - [继承](#继承)
  - [动态绑定](#动态绑定)
- [定义基类和派生类](#定义基类和派生类)
  - [定义基类](#定义基类)
    - [访问控制和继承](#访问控制和继承)
    - [习题](#习题)
  - [定义派生类](#定义派生类)
    - [派生类对象及派生类向基类的类型转换](#派生类对象及派生类向基类的类型转换)
    - [防止继承的发生](#防止继承的发生)
  - [类型转换与继承](#类型转换与继承)
    - [习题](#习题-1)
- [虚函数](#虚函数)
  - [回避虚函数的机制](#回避虚函数的机制)
  - [习题](#习题-2)
- [抽象基类](#抽象基类)
- [访问控制和继承](#访问控制和继承-1)
  - [受保护的成员](#受保护的成员)
  - [公有、私有和受保护继承](#公有私有和受保护继承)


# 概述


## 继承
这里再一次对于虚函数有了一个更深刻的理解：
1. 在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待
2. 对于与类型相关的函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数


## 动态绑定
使用基类的引用(或指针)调用一个虚函数时将发生动态绑定，也就是常说的多态。


# 定义基类和派生类


## 定义基类


### 访问控制和继承
派生类可以访问基类的公有成员，不能访问私有成员。还有一类protected成员：基类希望它的派生类有权访问该成员，同时禁止其他用户访问。


### 习题
1. protected和private有什么区别？
protected是受保护的访问标号，protected成员可以被该类的成员、友元和派生类成员(非友元)访问，而不可以被该类型的普通用户访问；<br>
private成员只能被基类成员和友元访问。

2. 定义自己的Quote和print_total函数。
```cpp
#include<iostream>

using namespace std;

class Quote{
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price):
        bookNo(book), price(sales_price) { }
    std::string isbn() const { return this->bookNo; }
    virtual double net_price(std::size_t n) const { return n * this->price; }
    virtual ~Quote() = default;

private:
    std::string bookNo;

protected:
    double price = 0.0;
};

double print_total(ostream &os, const Quote &item, size_t n){
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn() << " # sold: " << n << " total due: " << ret << endl;
    return ret; 
}
```


## 定义派生类


### 派生类对象及派生类向基类的类型转换
其实就是父类指针或引用指向子类对象，如下：
```cpp
Quote item;   // 基类对象
Bulk_quote = bulk;   // 派生类对象
Quote *p = &item;   // p指向Quote对象
p = &bulk;   // p指向bulk的Quote部分
Quote &r = bulk;   // r绑定到bulk的Quote部分
```


### 防止继承的发生
有时会定义这样一种类：不希望其他类继承它，或者不想考虑它是否适合作为一个基类，所以实现了一种防止继承发生的方法，即在类名后面跟一个关键字final，如下：
```cpp
class Noderived final { /* */ };   // Noderived不能作为基类
class Base { /* */ };   
class Last final : Base { /* */ };   // Last不能作为基类
class Bad : Noderived { /* */ };   // 错误：Noderived是final的
class Bad2 : Last { /* */ };   // 错误：Last是final的
```


## 类型转换与继承
当我们使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。如下：
```cpp
Bulk_quote bulk;   // 派生类对象
Quote item(bulk);   // 使用Quote::Quote(const Quote&)构造函数
item = bulk;   // 调用Quote::operator=(const Quote&)
```


### 习题
1. 给出静态类型和动态类型的定义。
静态类型在编译的时候就已经确定了，它是变量声明时的类型或表达式生成的类型；<br>
动态类型是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才能知道。<br>
如果一个变量非指针也非引用，则它的静态类型和动态类型永远一致；但基类的指针或引用的动态类型可能与其动态类型不一致。


# 虚函数


## 回避虚函数的机制
在一些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以达到这个目的，如下：
```cpp
double undiscounted = baseP->Quote::net_price(42);
```
如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行的时候该调用将被解析为对派生类版本的自身调用，从而导致无线递归。


## 习题
1. 有必要将一个成员函数同时声明成override和final吗？为什么？
override：说明派生类中的虚函数重写覆盖基类中的虚函数。<br>
final：将某个函数定义为final，则不允许后续的派生类来覆盖这个函数，否则会报错。<br>
同时将一个成员函数声明成override和final能够是我们的意图更加清晰。


# 抽象基类
其实就是介绍了具有纯虚函数的基类叫抽象基类，以及它的一些用法。最主要的就是：如果没有重写或定义纯虚函数，那么将无法实例化对象。


# 访问控制和继承


## 受保护的成员
1. 和私有成员相似，受保护的成员对于类的用户来说是不可访问的
2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可以访问的
3. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权
```cpp
class Base{
protected:
  int prot_mem;
};

class Sneaky: public Base{
  friend void clobber(Sneaky&);   // 能访问Sneaky::prot_mem
  friend void clobber(Base&);   // 不能访问Base::prot_mem
  int j;   // j默认是private
}
```


## 公有、私有和受保护继承
某个类对其继承而来的成员的访问权限收到两个因素的影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。例子如下：
```cpp
class Base{
public:
  void pub_mem();
protected:
  int prot_mem();
private:
  char priv_mem();
};

struct Pub_Derv: public Base{
  // 正确：派生类可以访问protected成员
  int f() { return prot_mem(); }
  // 错误：private成员对于派生类而言不可访问
  char g() { return priv_mem(); }
};

struct Priv_Derv: private Base{
  // private不影响派生类的访问权限
  int f1() const { return prot_mem(); }
};
```
结论：
1. 派生访问说明符对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响，对于基类成员的访问权限只与基类中的访问说明符有关
2. 派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限