- [STL](#stl)
  - [allocator类](#allocator类)
    - [为什么要出现](#为什么要出现)
    - [标准库allocator类及其算法](#标准库allocator类及其算法)
    - [allocator分配未构造的内存](#allocator分配未构造的内存)
    - [拷贝和填充未初始化内存的算法](#拷贝和填充未初始化内存的算法)
    - [习题](#习题)
  - [vector容器扩充与实现](#vector容器扩充与实现)
- [future](#future)
- [std::move和std::forward](#stdmove和stdforward)
- [emplace\_back 和 push\_back](#emplace_back-和-push_back)


# STL


## allocator类


### 为什么要出现

new在灵活性上有局限，主要表现在它将 **内存分配和对象构造** 组合在了一起；delete将 **对象析构和内存释放** 组合在了一起。在分配一个对象时，这样的做法肯定是没有什么问题的。但是当我们需要分配一大块内存并计划在这个内存上按需构造对象时，我们希望将内存分配和对象构造分离。也就是说，我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。<br>
如下面例子所示，将内存分配和对象构造组合在一起可能会导致不必要的浪费：

```cpp
string *const p = new string[n];   // 构造n个空string
string s;
string *q = p;   // q指向第一个string
while(cin >> s && q != p + n)
    *q++ = s;   // 赋予*q一个新值
const size_t size = q - p;   // 记录我们读取了多少个string
// 使用数组
delete [] p;   // p指向一个数组，释放内存
```

浪费体现在以下两方面：

1. new表达式分配并初始化了n个string，但是我们可能不需要n个string，少量string就已经足够了；
2. 每个要使用的对象被赋值了两遍：第一次是在默认初始化时，随后是在赋值时。


### 标准库allocator类及其算法

| 操作 | 含义 |
| -- | -- |
| allocator\<T> a| 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 |
| a.allocate(n) | 分配一段原始的、未构造的内存，保存了n个类型为T的对象 |
| a.deallocate(p, n) | 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用的allocate之前，用户必须对每个在这块内存中创建的对象调用destroy |
| a.construct(p, args) | p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来给p指向的内存中构造一个对象 | 
| a.destroy(p) | p为T*类型的指针，此算法对p指向的对象指向析构函数 |


### allocator分配未构造的内存

allocator分配的内存是未构造的，我们需要按需构造。如下：

```cpp
auto q = p;   // q指向最后构造的元素之后的位置
alloc.construct(q++);   // *q为空字符串
alloc.construct(q++, 5, 'c');   // *q为ccccc
alloc.construct(q++, "hi");   // *q为hi
```

还未构造对象就使用原始内存是错误的：

```cpp
cout << *p << endl;   // 正确，使用string的输出运算符
cout << *q << endl;   // 错误，q指向未构造的内存
```


### 拷贝和填充未初始化内存的算法

标准库为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。如下表：

| 操作 | 含义 |
| -- | -- |
| uninitialized_copy(b, e, b2) | 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大 |
| uninitialized_copy_n(b, n, b2) | 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中 |
| uninitialized_fill(b, e, t) | 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 |
| uninitialized_fill_n(b, n, t) | 从迭代器b指向的内存地址开始创建n个对象 |
例子如下：

```cpp
// 分配比vector<int> vi中元素所占有开间大一倍的动态内存
auto p = alloc.allocate(vi.size() * 2);
// 通过拷贝vi中的元素来构造从p开始的元素
auto q = uninitialized_copy(vi.begin(), vi.end(), p);
// 将剩余元素初始化为42
uninitialized_fill_n(q, vi.size(), 42);
```


### 习题

1. 使用allocator重写开头的例子。
```cpp
#include<iostream>
#include<string>
#include<memory>

using namespace std;

int main(int argc, char *argv[]){

    allocator<string> alloc;
    // 分配5个未初始化的string
    auto const p = alloc.allocate(5);
    string s;
    string *q = p;   // q指向第一个string
    while(cin >> s && q != p + 5)
        alloc.construct(q++, s);   // 用s初始化*q
    const size_t size = q - p;   // 记录读取了多少个string

    // 使用数组
    for(size_t i = 0; i < size; i++)
        cout << p[i] << " " << endl;

    while(q != p)   // 使用完毕后释放已构造的string
        alloc.destroy(--q);
    alloc.deallocate(p, 5);   // 释放内存

    return 0;
}
```

```shell
eason@eason:~/cpp_primer/chapter12$ g++ allocator.cpp -o allocator
eason@eason:~/cpp_primer/chapter12$ ./allocator 
hello
world
hello
hello
hello
hello
hello 
world 
hello 
hello 
hello 
```


## vector容器扩充与实现

详见代码随想录PDF，上面提到的allocator就是要掌握的，因为底层实现用到了。<br>
详细看了底层实现代码后，终于明白了这句话：一旦引起空间配置指向以前vector的所有迭代器都要失效。<br>


# future

[C++11 多线程（std::thread）详解](https://blog.csdn.net/sjc_0910/article/details/118861539?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171323622616800180652109%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171323622616800180652109&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-15-118861539-null-null.142^v100^control&utm_term=C%2B%2Bfuture&spm=1018.2226.3001.4187)：这篇文章详细介绍了C++中和并发相关的函数，收益匪浅！<br>



# std::move和std::forward

[C++11中std::move和std::forward到底干了啥](https://blog.csdn.net/albertsh/article/details/118886009?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-2-118886009-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>
[C++11的右值引用、移动语义（std::move）和完美转发（std::forward）详解](https://blog.csdn.net/weixin_43798887/article/details/117091176?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-117091176-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>
[C++的std::move与std::forward原理大白话总结](https://blog.csdn.net/newchenxf/article/details/117995131?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171331790616800197077232%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=171331790616800197077232&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-117995131-null-null.142^v100^control&utm_term=std%3A%3Aforward&spm=1018.2226.3001.4187)<br>


# emplace_back 和 push_back

[Why emplace_back is faster than push_back?](https://stackoverflow.com/questions/23717151/why-emplace-back-is-faster-than-push-back)<br>
[C++中push_back和emplace_back的区别](https://developer.aliyun.com/article/771502)<br>