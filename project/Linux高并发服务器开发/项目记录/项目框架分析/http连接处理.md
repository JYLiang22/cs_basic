- [基础知识](#基础知识)
  - [epoll](#epoll)
  - [HTTP报文格式](#http报文格式)
    - [请求报文](#请求报文)
    - [响应报文](#响应报文)
  - [HTTP状态码](#http状态码)
  - [有限状态机](#有限状态机)
  - [http处理流程](#http处理流程)
    - [http报文处理流程](#http报文处理流程)
    - [http类](#http类)
    - [epoll相关代码](#epoll相关代码)
    - [服务器接收http请求](#服务器接收http请求)
- [请求报文解析](#请求报文解析)
  - [流程图和状态机](#流程图和状态机)
  - [代码分析-http报文解析](#代码分析-http报文解析)
    - [HTTP\_CODE含义](#http_code含义)
    - [解析报文整体流程](#解析报文整体流程)
    - [从状态机逻辑](#从状态机逻辑)
    - [主状态机逻辑](#主状态机逻辑)
- [请求报文响应](#请求报文响应)
  - [基础API](#基础api)
  - [流程图](#流程图)
  - [代码](#代码)
    - [do\_request](#do_request)
    - [process\_write](#process_write)
    - [http\_conn::write](#http_connwrite)


# 基础知识


## epoll
介绍了epoll_create、epoll_ctl、epoll_wait三个函数，不多赘述<br>
介绍了select、poll、epoll和ET、LT，看小林文章，不多赘述<br>
**select、poll、epoll的应用场景不太理解**<br>


## HTTP报文格式


### 请求报文
请求报文有两种，GET和POST，这两个不太一样，但都是由这四部分组成的： **请求行（request line）、请求头部（header）、空行和请求数据**<br>
但是注意，**get请求没有消息体**，当解析完空行之后，便完成了报文的解析。
1. 请求行：用来说明请求类型，要访问的资源以及所使用的HTTP版本
2. 请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
   1. HOST，给出请求资源所在服务器的域名
   2. User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义，并且在每个请求中自动发送等
   3. Accept，说明用户代理可处理的媒体类型
   4. Accept-Encoding，说明用户代理支持的内容编码
   5. Accept-Language，说明用户代理能够处理的自然语言集
   6. Content-Type，说明实现主体的媒体类型
   7. Content-Length，说明实现主体的大小
   8. Connection，连接管理，可以是 **Keep-Alive或close** ，参考文章(https://xiaolincoding.com/network/3_tcp/tcp_http_keepalive.html)
3. 空行， **请求头部后面的空行是必须的** 即使第四部分的请求数据为空，也必须有空行
4. 请求数据也叫主体，可以添加任意的其他数据


### 响应报文
也是四个部分组成： **状态行、消息报头、空行和响应正文**
1. 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成
2. 消息报头，用来说明客户端要使用的一些附加信息，例如生成响应的日期和时间、编码类型等等
3. 空行，消息报头后面的空行是必须的
4. 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文


## HTTP状态码
这里主要讲了5大类，又细说了8小类，这里就不详细介绍了，可以参考博客。


## 有限状态机
这里目前也没有过多感悟，感觉就是利用if-else  switch-case语句进行状态判断和跳转


## http处理流程


### http报文处理流程
概述：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理<br>
下面主要解析三类代码


### http类
先介绍、定义了各种属性，感觉还是要结合下面的代码去理解这些属性的意义，否则的话理解起来很难。<br>


### epoll相关代码
这个代码还是比较简单，只要弄清楚epoll原理和搞清楚相关库函数，都是不难理解的。


### 服务器接收http请求
概述：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理


# 请求报文解析
概述：工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。所以将结合流程图和代码分别对状态机和服务器解析请求报文进行详解。<br>


## 流程图和状态机
这里的主要作用是解析请求报文，由前面的基础知识可以知道：<br>
```请求报文 = 请求行 + 请求头 + 空行 + 请求数据```<br>
所以这里需要对每一部分数据都进行解析，从文中的图可以看出来，主状态机负责解析请求行、请求头和请求数据。<br>

所以对应地，主状态机有三种状态：
1. CHECK_STATE_REQUESTLINE，解析请求行
2. CHECK_STATE_HEADER，解析请求头
3. CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

而由于每一个部分可能包含多个语句，所以从状态机负责解析这里面的多个语句，并对应产生三种状态：
1. LINE_OK，完整读取一行
2. LINE_BAD，报文语法有误
3. LINE_OPEN，读取的行不完整


## 代码分析-http报文解析
这里主要进行两个任务：报文解析和报文响应。


### HTTP_CODE含义
主要用于报文解析，判断解析的结果，从而确定请求报文是否正确，决定下一步动作是继续监听还是进行报文响应。<br>

下面这三个部分，目前看来好像没有什么好解释的，感觉只要理解了主从状态机的原理以及报文进一步的细致的格式，一切都迎刃而解了！


### 解析报文整体流程


### 从状态机逻辑


### 主状态机逻辑
这里有几个难点要理解的，但是这几个难点的本质原因还是在于get和post请求报文的格式不一样。
1. GET和POST请求报文的区别之一是有无消息体部分，GET请求没有消息体，当解析完空行之后，便完成了报文的解析。
2. 在GET请求报文中，每一行都是\r\n作为结束；但，在POST请求报文中，消息体的末尾没有任何字符。


# 请求报文响应
概述：解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端<br>


## 基础API
主要介绍这四个：stat、mmap、iovec、writev，这里不多赘述。


## 流程图
如前面所述，服务器端接收HTTP请求报文并调用process_read对其进行解析，根据解析结果HTTP_CODE，进入相应的逻辑和模块。<br>

服务器子线程完成报文的解析与响应；主线程监测读写事件。具体可以参考博客中的图和整体框架里面的图理解，感觉这里还是比较容易理解的。<br>


## 代码
主要分析了以下三个代码块：do_request、process_write、http_conn::write，具体解析如下。


### do_request
根据请求报文中解析出的请求资源，进行各种对应功能的页面跳转。


### process_write
根据do_request的返回状态，服务器子线程调用process_write向m_write_buf中写入响应报文。


### http_conn::write
服务器子线程调用process_write完成响应报文，随后注册epollout事件。服务器主线程检测写事件，并调用http_conn::write函数将响应报文发送给浏览器端。