- [需要了解的基础知识](#需要了解的基础知识)
  - [socket编程](#socket编程)
  - [Reactor模式和Proactor模式](#reactor模式和proactor模式)
  - [什么是同步I/O，什么是异步I/O](#什么是同步io什么是异步io)
  - [I/O 多路复用：select/poll/epoll](#io-多路复用selectpollepoll)
- [Web服务器如何接收客户端发来的HTTP请求报文](#web服务器如何接收客户端发来的http请求报文)
- [线程同步机制封装类](#线程同步机制封装类)
  - [基础知识](#基础知识)
    - [RALL](#rall)
    - [信号量](#信号量)
    - [互斥量](#互斥量)
    - [条件变量](#条件变量)
  - [功能](#功能)
- [半同步半反应堆线程池](#半同步半反应堆线程池)
  - [基础知识](#基础知识-1)
    - [服务器编程基本框架、五种I/O模型、事件处理模式](#服务器编程基本框架五种io模型事件处理模式)
    - [同步I/O模拟proactor模式](#同步io模拟proactor模式)
    - [线程池](#线程池)
    - [静态成员变量/函数](#静态成员变量函数)
  - [代码分析](#代码分析)


# 需要了解的基础知识


## socket编程
不讲了，这个挺基础的


## Reactor模式和Proactor模式
参考小林的文章(https://xiaolincoding.com/os/8_network_system/reactor.html#_9-3-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-reactor-%E5%92%8C-proactor)<br>

通常使用 **同步I/O模型** （如epoll_wait）实现Reactor，使用 **异步I/O** （如aio_read和aio_write）实现Proactor。但在此项目中，我们使用的是同步I/O模拟的Proactor事件处理模式。


## 什么是同步I/O，什么是异步I/O
真正意义上的 异步IO 是说 **内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据** 。
select / poll / epoll 都是 **同步IO** 的多路复用模式

1. 同步和异步
同步和异步关注的是 **消息通信机制**<br>
所谓同步，就是在发出一个 *调用* 时，没得到结果之前，该 *调用* 就 **不返回** 。但是一旦调用返回就得到返回值了， *调用者* 主动等待这个 *调用* 的结果<br>
所谓异步，就是在发出一个 *调用* 时，这个 *调用* 就 **直接返回** 了，不管返回有没有结果。当一个异步过程调用发出后， *被调用者* 通过状态来通知 *调用者* ，或者通过回调函数处理这个调用<br>

2. 阻塞和非阻塞
阻塞和非阻塞关注的是 **程序在等待调用结果时的状态**<br>
阻塞调用是指调用结果返回之前， **当前线程会被挂起** 。调用线程只有在 **得到结果** 之后才返回<br>
非阻塞调用是指在 **不能立即得到结果之前** ，该调用 **不会阻塞当前线程**<br>

网络上的例子：老张爱喝茶，废话不说，煮开水。<br>
出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>

1. 老张把水壶放到火上，立等水开。（同步阻塞）：立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步
2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）：老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了
3. 老张把响水壶放到火上，立等水开。（异步阻塞）：立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了
4. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）：老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了

所谓同步异步，只是对于 **水壶** 而言。普通水壶，同步；响水壶，异步。对应的也就是 **消息通信机制**<br>
虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。<br>
所谓阻塞非阻塞，仅仅对于 **老张** 而言。立等的老张，阻塞；看电视的老张，非阻塞。对应的也就是 **程序等待结果时的状态**<br>
情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。**虽然3中响水壶是异步的，可对于立等的老张没有太大的意义**。所以一般 **异步是配合非阻塞使用** 的，这样才能发挥异步的效用。<br>


## I/O 多路复用：select/poll/epoll
具体可以参考小林的文章(https://xiaolincoding.com/os/8_network_system/selete_poll_epoll.html)


# Web服务器如何接收客户端发来的HTTP请求报文
通过最基础的socket监听来自用户的请求，由于这个代码实在是太基础了，所以这里就不放代码了。<br>

远端的很多用户会尝试去connect()这个Web Server上正在listen的这个port，而监听到的这些连接会排队等待被accept()。由于用户连接请求是随机到达的**异步**事件，每当监听socket（listenfd）listen到新的客户连接并且放入监听队列，我们都需要告诉我们的Web服务器有连接来了，accept这个连接，并分配一个逻辑单元来处理这个用户请求。而且，我们在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发，同时处理多个事件，后面会提到**使用线程池实现并发**）。这里，服务器通过epoll这种I/O复用技术（还有select和poll）来实现对监听socket（listenfd）和连接socket（客户请求）的同时监听。注意I/O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。<br>

上一段话是作者的原话，其实就是介绍了为什么要使用线程池来实现并发：
1. 由于用户连接请求是**随机到达的异步事件**，并且我们在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发，同时处理多个事件，后面会提到**使用线程池实现并发**）
2. 服务器通过epoll这种I/O复用技术（还有select和poll）来实现对监听socket（listenfd）和连接socket（客户请求）的同时监听，但由于**它本身是阻塞的**，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发）


# 线程同步机制封装类


## 基础知识


### RALL
1. RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”
2. 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该 **使用类来管理资源** ，将 **资源和对象的生命周期绑定**
3. RAII的核心思想是 **将资源或者状态与对象的生命周期绑定** ，通过C++的语言机制，实现资源和状态的安全管理，智能指针是RAII最好的例子


### 信号量
等待P和信号V，函数如下：
```
sem_init函数用于初始化一个未命名的信号量
sem_destory函数用于销毁信号量
sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞
sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程
```


### 互斥量
用于保护关键代码段，确保独占式访问。函数如下：
```
pthread_mutex_init函数用于初始化互斥锁
pthread_mutex_destory函数用于销毁互斥锁
pthread_mutex_lock函数以原子操作方式给互斥锁加锁
pthread_mutex_unlock函数以原子操作方式给互斥锁解锁
```


### 条件变量
条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时，唤醒等待这个共享数据的线程。函数如下：
```
pthread_cond_init函数用于初始化条件变量
pthread_cond_destory函数销毁条件变量
pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件变量的线程
pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 mutex参数(加锁的互斥锁) ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. 也就是说函数内部会有一次解锁和加锁操作.
```


## 功能
主要是通过锁机制，实现多线程同步，确保任一时刻只能有一个线程能进入关键代码段， **为下面的线程池提供可调用函数** 。<br>

**自己看了挺久才看懂的代码**：
```cpp
//条件变量的使用机制需要配合锁来使用
//内部会有一次加锁和解锁
//封装起来会使得更加简洁
bool wait()
{
  int ret=0;
  pthread_mutex_lock(&m_mutex);
  ret=pthread_cond_wait(&m_cond,&m_mutex);
/*
主要是这里理解了挺久，直到看到了这句话：函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. 也就是说函数内部会有一次解锁和加锁操作。
刚开始的疑惑在于忽略了函数内部会有一次解锁和加锁操作，因为按照操作系统里面说过的，是要先加锁条件变量再锁互斥量的，否则当条件变量没有空闲时，会导致其它想要访问保护代码段的程序无法正常运行。
*/
  pthread_mutex_unlock(&m_mutex);
  return ret==0;
}
bool signal()
{
  return pthread_cond_signal(&m_cond)==0;
}
```


# 半同步半反应堆线程池


## 基础知识


### 服务器编程基本框架、五种I/O模型、事件处理模式
这几个小林coding里面都有详细说，只看看对应文章就行


### 同步I/O模拟proactor模式
这个小林coding里面也有说到，因为异步I/O不成熟，这也使得基于**Linux 的高性能网络程序都是使用 Reactor 方案** ，但是这个项目用的是 **使用同步I/O模拟实现proactor模式**。<br>

并发模式中的同步和异步：这个上面篇幅和小林coding都有介绍。<br>

以下均可参考图理解：<br>![Alt text](../image/%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%9B%BE.png)<br>

半同步/半异步模式工作流程
1. 同步线程用于处理 **客户逻辑**
2. 异步线程用于处理 **I/O事件**
3. 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
4. 请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象

半同步/半反应堆工作流程（以Proactor模式为例）
1. 主线程充当异步线程，负责监听所有socket上的事件
2. 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
3. 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
4. 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权


### 线程池
小林coding的文章有介绍


### 静态成员变量/函数
cpp基础，不多赘述


## 代码分析
一定一定一定要记得，结合框架图和目的理解，这样就不会过早陷入细节了。<br>
